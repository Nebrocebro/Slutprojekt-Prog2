<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="public/style.css">
    <style>
      canvas {
        border: 1px solid #000;
      }
    </style>
    <title>Move Circle</title>
  </head>
  <body>
    <nav>
      <!-- Lägg till action="/addUser" och method="post" när "spelet" är klart -->
      <form id="addUserForm" onsubmit="submitForm(event)" enctype="multipart/form-data" style="margin-top: 5px; margin-bottom: 5px;">
        <label for="username">* Username:</label>
        <input type="text" id="usernameinput" name="username" autocomplete="off" placeholder="Nickname" style="color: black;" required/><br>

        <label for="passwd">* Password:</label>
        <input type="password" id="passwd" name="passwd" style="color: #000;" required><br>
            
        <label for="profilePic">Profile Picture (Not required):</label>
        <input type="file" id="profilePic" name="profilePic"><br>

        <label for="circolor">Give your blob your favourite color! (Not required)</label>
        <input type="color" name="circolor" id="circolor" style="border-radius: 100%;"><br>

        <button type="submit" style="color: black;">Submit</button>
      </form>
      <button onclick="submitForm(event)" style="color: black; float: right; padding: 5px; border-radius: 15px;">Start Game</button>
      <button onclick="window.location.reload()" style="color: black; float: right; padding: 5px; border-radius: 15px;">Start Over</button>
    </nav>
    <br>
    <div id="maincontainer">
      <h1>Circle Mover!</h1>
      <canvas id="myCanvas" width="600" height="600"></canvas>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script>
    const canvas = document.getElementById("myCanvas")
    const ctx = canvas.getContext("2d")
    const devicePixelRatio = window.devicePixelRatio || 1;
    canvas.width = canvas.width * devicePixelRatio;
    canvas.height = canvas.height * devicePixelRatio;
    ctx.scale(devicePixelRatio, devicePixelRatio);
    ctx.imageSmoothingEnabled = false;

    const socket = io();
    const speed = 2;
    let circle = null;
    let username = "";
    let users = {};
    let foods = [];
    const movement = {
      up: false,
      down: false,
      left: false,
      right: false
    };
    
    // let circleX = 50
    // let circleY = 50
    // var circleRadius = 20
    // let circleColor = "blue"

    function getRandomInt(min, max) {
      const minCeiled = Math.ceil(min);
      const maxFloored = Math.floor(max);
      return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled);
    }

    class Circle {
      constructor(id, username, x, y, radius, color) {
        this.id = id;
        this.username = username;
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
      }

      draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.stroke();
        ctx.font = '8px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = 'white';
        ctx.fillText(this.username, this.x, this.y);
      }

      move(dx, dy, speed) {
        this.x += dx * speed;
        this.y += dy * speed;
      }
    }

    class Food {
      constructor(x, y, radius, color) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
      }

      draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.stroke();
      }
    }

    // function drawCircle(x, y, color, username) {
    //   ctx.beginPath();
    //   ctx.arc(x, y, circleRadius, 0, 2 * Math.PI);
    //   ctx.fillStyle = color;
    //   ctx.fill();
    //   ctx.stroke();
    //   ctx.font = '8px Arial';
    //   ctx.textAlign = 'center';
    //   ctx.textBaseline = 'middle';
    //   ctx.fillStyle = 'white'; // Set text color
    //   ctx.fillText(username, x, y);
    // }

    // function drawFood(x, y, color) {
    //   ctx.beginPath();
    //   ctx.arc(x, y, 5, 0, 2 * Math.PI);
    //   ctx.fillStyle = color;
    //   ctx.fill();
    //   ctx.stroke();
    // }

    function drawAllUsers() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const userId in users) {
        const user = users[userId];
        // drawCircle(user.x, user.y, user.color, user.username);
        user.draw(ctx);
      }
    }

    function drawAllFoods() {
      for (const food of foods) {
        // drawFood(food.x, food.y, food.color);
        food.draw(ctx);
      }
    }

    const keyUpdateInterval = 16;
    let keyUpdateTimer;

    function handleKeyPress(event) {
      switch (event.key) {
        case "ArrowUp":
        case "w":
          movement.up = true;
          break;
        case "ArrowDown":
        case "s":
          movement.down = true;
          break;
        case "ArrowLeft":
        case "a":
          movement.left = true;
          break;
        case "ArrowRight":
        case "d":
          movement.right = true;
          break;
      }

      if (!keyUpdateTimer) {
        keyUpdateTimer = setInterval(updatePosition, keyUpdateInterval);
      }
    }

    function handleKeyRelease(event) {
      switch (event.key) {
        case "ArrowUp":
        case "w":
          movement.up = false;
          break;
        case "ArrowDown":
        case "s":
          movement.down = false;
          break;
        case "ArrowLeft":
        case "a":
          movement.left = false;
          break;
        case "ArrowRight":
        case "d":
          movement.right = false;
          break;
      }

      if (!movement.up && !movement.down && !movement.left && !movement.right) {
        clearInterval(keyUpdateTimer);
        keyUpdateTimer = null;
      }
    }

    function isCollision(circleX, circleY, circleRadius, foodX, foodY, foodRadius) {
      const dx = circleX - foodX;
      const dy = circleY - foodY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < circleRadius + foodRadius;
    }

    function handleCollisions() {
      for (let i = foods.length - 1; i >= 0; i--) {
        if (isCollision(circle.x, circle.y, circle.radius, foods[i].x, foods[i].y, foods[i].radius)) {
          // circle.radius += (food.radius/5);
          console.log("waitwat", circle.radius)
          foods.splice(i, 1);
          socket.emit("foodEaten", { foodIndex: i, playerId: socket.id });
        }
      }
    }

    function updatePosition() {
      let dx = 0;
      let dy = 0;

      if (movement.up) dy -= 1;
      if (movement.down) dy += 1;
      if (movement.left) dx -= 1;
      if (movement.right) dx += 1;

      if (dx !== 0 || dy !== 0) {
        circle.move(dx, dy, speed);
        circle.draw(ctx);
        // circleX += dx * speed;
        // circleY += dy * speed;
        // drawCircle(circleX, circleY, circleColor);
        // socket.emit("updatePosition", { id: socket.id, x: circleX, y: circleY, color: circleColor, username: username });
        socket.emit("updatePosition", { id: socket.id, x: circle.x, y: circle.y, color: circle.color, username: username })
        handleCollisions();
      }
    }

    function submitForm(event) {
      event.preventDefault();
      username = document.getElementById("usernameinput").value;
      const favColor = document.getElementById("circolor").value;
      const circleX = 50;
      const circleY = 50;
      const circleRadius = 20;
      circle = new Circle(socket.id, username, circleX, circleY, circleRadius, favColor);
      socket.emit("newUser", { username, color: favColor, x: circleX, y: circleY, canvasWidth: canvas.width, canvasHeight: canvas.height });
      document.addEventListener("keydown", handleKeyPress);
      document.addEventListener("keyup", handleKeyRelease);
      document.getElementById("addUserForm").style.display = "none";
    }

    socket.on("updateFoods", ({ foods: updatedFoods, playerId, eatenFoodVal }) => {
      console.log(playerId);
      foods = updatedFoods.map(food => new Food(food.x, food.y, food.radius, food.color));
      drawAllFoods();
      for (const userId in users) {
        const user = users[userId];
        console.log(user.radius, " rad1");
        if (user.id == playerId) {
        // user.radius += (food.radius/5);
          user.radius = user.radius + eatenFoodVal/5;
        console.log(user.radius, " rad2");
        // console.log(users[playerId].circleRadius); 
        // console.log(users[user.id].circleRadius);
        }
      }
    });

    socket.on("updateUsers", (data) => {
      // users = data.users;
      users = {};
      for (const userId in data.users) {
        const userData = data.users[userId];
        users[userId] = new Circle(userData.id, userData.username, userData.x, userData.y, userData.circleRadius, userData.color)
      }
      foods = data.foods.map(food => new Food(food.x, food.y, food.radius, food.color));
      // foods.length = 0;
      drawAllUsers();
      drawAllFoods();
    });

    socket.on("updatePosition", (data) => {
      if (users[data.id]) {
        users[data.id].x = data.x;
        users[data.id].y = data.y;
      drawAllUsers();
      drawAllFoods();
      }
    });

    socket.on("newUserAndFoods", (data) => {
      users = {};
      for (const userId in data.users) {
        const userData = data.users[userId];
        users[userId] = new Circle(userData.id, userData.username, userData.x, userData.y, userData.circleRadius, userData.color);
      }
      foods = data.foods.map(food => new Food(food.x, food.y, food.radius, food.color));
      drawAllUsers();
      // socket.emit("updateUsers");
      drawAllFoods();
      // socket.emit("updatePosition");
    });

    </script>
  </body>
</html>